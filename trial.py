from dash import Dash, html, dcc, Input, Output
import pandas as pd
import plotly.express as px


external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']


app = Dash(__name__, external_stylesheets=external_stylesheets)

df = pd.read_csv('assign2_wastedata.csv',error_bad_lines=False)


app.layout = html.Div([
    html.Div([
	html.Div([
            dcc.Dropdown(
                 ['Landfill','Recycling','Compost'],
                id='waste-type',
            )
        ],
        style={'width': '49%', 'float':'left'}),
	
	html.Div([
	    dcc.Slider(df['Year'].min(), df['Year'].max(),
            step=None,
            id='crossfilter-year--slider',
            value=df['Year'].max(),
            marks={str(year): str(year) for year in df['Year'].unique()}
    	    )
        ], style={'width': '49%','float':'right'})
	

    ], 	style={'padding': '5px 5px'}),


     html.Div([
 	 html.Div([
		dcc.Graph(id="piechart")
		  ],style={'width': '23%', 'float':'left'}),

	
     html.Div([
             dcc.Graph(id='histogram')
    	        ], style={'float':'right', 'width': '38%'}),

     html.Div([
		dcc.Graph(id="horizontalbarchart")
		  ],style={'width': '38%', 'float':'left'})
   
	
	
    ], 	style={'padding': '5px 5px','height' :'100%'}),


 
  
])

# Callbacks 

# Pie Chart for Candidates 

@app.callback(
    Output(component_id='piechart', component_property='figure'),
    [Input(component_id='waste-type', component_property='value')],
    [Input(component_id='crossfilter-year--slider', component_property='value')]
)

def build_graph_individuals(column_chosen,year_chosen):
     dff = df[df['Year'] == year_chosen]
     streamdata = dff[dff['MainStream'] == column_chosen]  
     fig_individuals = px.pie(streamdata,names="Building",values="Weight",hole=0.5, color_discrete_sequence=px.colors.sequential.RdBu,title="<b>Total Waste Generated by selected Stream</b>")  
     fig_individuals.update_layout(
     font_size=10,
     title_font_family="Times New Roman",
     title_font_color="green",
     legend_title_font_color="green",
     title_x=0.5
      )  
     return fig_individuals


@app.callback(
    Output(component_id='histogram', component_property='figure'),
    [Input(component_id='waste-type', component_property='value')],
    [Input(component_id='crossfilter-year--slider', component_property='value')]
)
def build_puritybargraph(column_chosen,year_chosen):
     dff = df[df['Year'] == year_chosen]
     streamdata = dff[dff['MainStream'] == column_chosen] 
     missorteddata = streamdata[streamdata ['Stream'] == column_chosen]   
     fig = px.bar(missorteddata, y="Building", x="Weight",color="Building", color_discrete_sequence=px.colors.sequential.RdBu ,hover_data=['Weight'],barmode = 'group',orientation ='h',title="<b>Purity Ranking of selected stream</b>")
     fig.update_layout(
     font_size=10,
     title_font_family="Times New Roman",
     title_font_color="green",
     legend_title_font_color="green",
     yaxis={'categoryorder':'total ascending'},
     title_x=0.5
      )  

     return fig


@app.callback(
    Output(component_id='horizontalbarchart', component_property='figure'),
    [Input(component_id='waste-type', component_property='value')],
    [Input(component_id='crossfilter-year--slider', component_property='value')]
)
def build_misortedbargraph(column_chosen,year_chosen):
     dff = df[df['Year'] == year_chosen]
     streamdata = dff[dff['MainStream'] == column_chosen] 
     missorteddata = streamdata[streamdata ['Stream'] != column_chosen]   
     fig = px.bar(missorteddata, x="Building", y="Weight",color="Stream", color_discrete_sequence=px.colors.sequential.RdBu,hover_data=['Weight'],title="<b>Missorted weight of selected stream</b>")
     fig.update_layout(
     font_size=10,
     title_font_family="Times New Roman",
     title_font_color="green",
     legend_title_font_color="green",
     title_x=0.5
      )  
     return fig


if __name__ == '__main__':
    app.run_server(debug=True)
